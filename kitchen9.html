<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Kitchen Dashboard</title>
  <style>
    body {
      font-family: sans-serif;
      padding: 20px;
      max-width: 600px;
      margin: auto;
      background: #fefefe;
    }
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #d9534f;
    }
    .order {
      border: 2px solid #ccc;
      padding: 12px;
      margin-bottom: 15px;
      border-radius: 8px;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      /* Add transition for smooth removal */
      transition: opacity 0.5s ease-out, transform 0.5s ease-out;
    }
    .order.ready {
      border-color: #5cb85c;
      background: #e6ffe6;
    }
    /* Style for orders about to be removed */
    .order.served {
        opacity: 0;
        transform: translateX(-100%);
    }
    .order h2 {
      margin: 0 0 10px;
      font-size: 1.4em;
      color: #333;
      border-bottom: 1px dashed #eee;
      padding-bottom: 5px;
    }
    .order p {
      margin: 5px 0;
      font-size: 1.1em;
      font-weight: 500;
    }
    .order-items {
      list-style: none;
      padding: 0;
      margin-top: 10px;
    }
    .order-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px dotted #eee;
    }
    .item-details {
      flex-grow: 1;
    }
    .item-name {
      font-weight: bold;
    }
    .item-note {
      font-style: italic;
      color: #666;
      display: block;
      font-size: 0.9em;
    }
    .item-quantity {
      font-size: 1.2em;
      color: #d9534f;
      margin-right: 15px;
    }
    
    /* --- Item Status Button Styles --- */
    .status-button {
      background: #999; /* Default (New/Saved) status is neutral gray */
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.9em;
      transition: background 0.2s;
      width: 120px; /* Wider button for better labels */
      text-align: center;
    }
    .status-button:hover:not(:disabled) {
      background: #777;
    }
    
    .status-in-progress {
        background-color: #f0ad4e; /* Orange for Cooking */
    }
    .status-in-progress:hover {
        background-color: #ec971f;
    }
    
    .status-ready {
        background-color: #5cb85c; /* Green for Completed */
    }
    .status-ready:hover {
        background-color: #4cae4c;
    }
    /* --- End Item Status Button Styles --- */


    /* --- Order Completion Button Styles --- */
    .status-button.complete {
      background: #5cb85c;
      width: 100%;
      margin-top: 15px;
      font-size: 1.1em;
      padding: 10px;
    }
    .status-button.complete:hover:not(:disabled) {
      background: #4cae4c;
    }
    .status-button.complete:disabled {
        background-color: #ccc;
        cursor: not-allowed;
    }
    /* --- End Order Completion Button Styles --- */


    .action-group {
      display: flex;
      gap: 10px;
      margin-top: 10px;
    }
    .action-group .status-button {
        flex: 1;
        width: auto;
    }
    
  </style>
</head>
<body>
  <h1>üçî Burnt Diner Kitchen Display</h1>

  <div id="ordersContainer">
    <p style="text-align: center; color: #999;">Waiting for new orders...</p>
  </div>

  <script type="module">
    // --- Firebase SDK Imports ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, updateDoc, onSnapshot, collection, query, where, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    setLogLevel('Debug');

    // --- Global Variables ---
    let db;
    let auth;
    let ordersCollectionRef;
    let appId = 'default-app-id';

    // Store order IDs that have been seen to prevent duplication
    const seenOrderIds = new Set();
    
    // --- Firebase Initialization ---
    const defaultFirebaseConfig = { 
        apiKey: "AIzaSyDhofFG3SN-q3l4n4udHv7tOWT6ewb9aQ8", 
        authDomain: "burnt-pos.firebaseapp.com", 
        projectId: "burnt-pos", 
        storageBucket: "burnt-pos.firebasestorage.app", 
        messagingSenderId: "186475223375", 
        appId: "1:186475223375:web:0ecf0136f9af26985a8d3a", 
        measurementId: "G-NWTNRQ3GCM" 
    };

    let firebaseConfig;

    try {
        firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : defaultFirebaseConfig;
        appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    } catch (e) {
        console.error("Error parsing __firebase_config, using default.", e);
        firebaseConfig = defaultFirebaseConfig;
    }

    const app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    auth = getAuth(app);
    
    // The collection path for public orders
    ordersCollectionRef = collection(db, `artifacts/${appId}/public/data/orders`);

    // --- Authentication and Order Listener Setup ---
    (async function initializeAuth() {
        try {
            if (typeof __initial_auth_token !== 'undefined') {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                // Kitchen is read-only, sign in anonymously if no token is available
                await signInAnonymously(auth);
            }
            console.log("Firebase Auth initialized for Kitchen Dashboard.");
            listenForOrders();
        } catch (error) {
            console.error("Firebase Auth Error:", error);
            document.getElementById("ordersContainer").innerHTML = `<p class="error" style="color:red; text-align:center;">
                Authentication failed. Cannot connect to orders database.
            </p>`;
        }
    })();

    // --- Firestore Listener ---
    function listenForOrders() {
        if (!ordersCollectionRef) return;
        
        // CRITICAL FIX: Query for the new 'saved' status from POS AND 'in_progress'
        // Also, remove orderBy to prevent common index errors which cause query failure.
        const q = query(
            ordersCollectionRef, 
            where('status', 'in', ['saved', 'in_progress'])
        );
        
        console.log("Starting real-time listener for orders...");

        onSnapshot(q, (snapshot) => {
            const ordersContainer = document.getElementById('ordersContainer');
            
            if (snapshot.empty && seenOrderIds.size === 0) {
                ordersContainer.innerHTML = '<p style="text-align: center; color: #999;">Waiting for new orders...</p>';
            }

            // Create a temporary object to hold current orders for sorting
            const currentOrders = {};

            snapshot.docChanges().forEach((change) => {
                const order = { id: change.doc.id, ...change.doc.data() };
                
                if (change.type === "added" || change.type === "modified") {
                    // Update our temporary list
                    currentOrders[order.id] = order;
                } else if (change.type === "removed") {
                    // Handle removal visually
                    const orderDiv = document.querySelector(`.order[data-order-id="${order.id}"]`);
                    if (orderDiv) {
                        orderDiv.remove();
                        seenOrderIds.delete(order.id);
                    }
                }
            });

            // Get the IDs from the current snapshot and sort them by the offlineTime (or check if createdAt exists)
            const sortedOrders = Object.values(currentOrders).sort((a, b) => {
                const timeA = a.offlineTime || (a.createdAt?.seconds * 1000) || 0;
                const timeB = b.offlineTime || (b.createdAt?.seconds * 1000) || 0;
                return timeA - timeB; // Sort ascending (oldest orders first)
            });


            // Now update the DOM based on the sorted list
            sortedOrders.forEach(order => {
                renderOrder(order);
                seenOrderIds.add(order.id);
            });
            
            if (ordersContainer.children.length === 0 && sortedOrders.length > 0) {
                // If there are orders but the container is empty, render them all (should be handled above, but as a fallback)
                sortedOrders.forEach(renderOrder);
            }
        }, (error) => {
            console.error("Error listening to orders:", error);
            document.getElementById("ordersContainer").innerHTML = `<p class="error" style="color:red; text-align:center;">
                Error loading orders: ${error.message}
            </p>`;
        });
    }


    // --- Render Functions ---
    function renderOrder(order) {
        const ordersContainer = document.getElementById('ordersContainer');
        let orderDiv = document.querySelector(`.order[data-order-id="${order.id}"]`);
        
        const timestamp = order.createdAt ? new Date(order.createdAt.seconds * 1000).toLocaleTimeString() : 'N/A';
        
        // If the order is brand new or not yet rendered
        if (!orderDiv) {
            orderDiv = document.createElement('div');
            orderDiv.classList.add('order');
            orderDiv.setAttribute('data-order-id', order.id);
            ordersContainer.insertBefore(orderDiv, ordersContainer.firstChild); // Insert new orders at the top (newest first)
        }
        
        // Remove 'ready' class if status changes back (e.g., from ready to in_progress)
        orderDiv.classList.remove('ready'); 
        if (order.status === 'ready') {
            orderDiv.classList.add('ready');
        }

        const itemsHtml = order.items.map((item, index) => {
            // Default to 'saved' (New) if kitchenStatus is missing (e.g., from POS)
            const currentKitchenStatus = item.kitchenStatus || 'saved';
            let nextStatus;
            let buttonText;
            let buttonClasses = 'status-button';
            
            // Define the three-state cycle and button display: New -> Cooking -> Completed
            if (currentKitchenStatus === 'ready') {
                // Current state: Completed
                nextStatus = 'in_progress';
                buttonText = 'Completed! (Undo)'; 
                buttonClasses += ' status-ready';
            } else if (currentKitchenStatus === 'in_progress') {
                // Current state: Cooking
                nextStatus = 'ready';
                buttonText = 'Complete Item';
                buttonClasses += ' status-in-progress';
            } else { // 'saved' or any other initial state
                // Current state: New
                nextStatus = 'in_progress';
                buttonText = 'Start Cooking';
                // Uses default status-button color (gray) for 'saved'
            }
            
            return `
                <li class="order-item" data-item-index="${index}">
                    <div class="item-details">
                        <span class="item-quantity">${item.qty}x</span>
                        <span class="item-name">${item.name} (${item.code})</span>
                        ${item.note ? `<span class="item-note">Note: ${item.note}</span>` : ''}
                    </div>
                    <div class="action-group">
                        <button class="${buttonClasses}" 
                            onclick="updateItemStatus('${order.id}', ${index}, '${nextStatus}', this)">
                            ${buttonText}
                        </button>
                    </div>
                </li>
            `;
        }).join('');

        const allItemsReady = order.items.every(item => item.kitchenStatus === 'ready');
        
        orderDiv.innerHTML = `
            <h2>Order #${order.id.substring(0, 5).toUpperCase()} (${order.orderType})</h2>
            <p><strong>Customer:</strong> ${order.customerName}</p>
            <p><strong>Total:</strong> ‚Ç±${order.total.toFixed(0)}</p>
            <p style="font-size: 0.9em; color: #666;">Placed at: ${timestamp}</p>
            
            <ul class="order-items">
                ${itemsHtml}
            </ul>
            
            <button class="status-button complete" onclick="completeOrderAndServe(this)" ${allItemsReady ? '' : 'disabled'}>
                ‚úÖ ${allItemsReady ? 'Order Ready - Tap to Serve' : 'Wait for all items to be Completed'}
            </button>
        `;

    }


    // --- Action Functions ---

    // Function to update the status of an individual item
    window.updateItemStatus = async function(orderId, itemIndex, nextStatus, button) {
        // Prevent action if order is already marked for serving
        if (button.closest('.order').classList.contains('ready')) return;

        // 1. Locally update the button state immediately
        button.textContent = 'Updating...';
        button.disabled = true;

        try {
            const orderDocRef = doc(ordersCollectionRef, orderId);
            // Must fetch document to safely update the nested array element
            const docSnapshot = await getDoc(orderDocRef); 
            
            if (docSnapshot.exists()) {
                const orderData = docSnapshot.data();
                // We use structuredClone to ensure we are working with a fresh, modifiable copy of the array.
                const items = structuredClone(orderData.items); 

                // Ensure the items array and index are valid
                if (items && items[itemIndex]) {
                    items[itemIndex].kitchenStatus = nextStatus;

                    // 2. Update the document in Firestore
                    await updateDoc(orderDocRef, { items: items });
                    console.log(`Item ${itemIndex} in Order ${orderId} status updated to ${nextStatus}.`);
                } else {
                     console.error("Item index or array invalid.");
                }
            } else {
                 console.error("Order document does not exist.");
            }

        } catch (error) {
            console.error("Error updating document:", error);
            // Re-enable button on error (real-time listener will correct the state)
            button.disabled = false;
        }
      }

    // --- NEW Function for Order-Level Completion (Final Check) ---
    window.completeOrderAndServe = function(button) {
      const orderDiv = button.closest('.order');
      const orderId = orderDiv.getAttribute('data-order-id');
      
      // 1. Visually mark as ready
      button.textContent = "Served - Removing Soon...";
      button.disabled = true;
      orderDiv.classList.add("ready");

      // 2. Update the database to mark as served permanently
      if (orderId) {
        const orderDocRef = doc(ordersCollectionRef, orderId);
        updateDoc(orderDocRef, {
            status: 'served',
            servedAt: new Date().toISOString()
        }).then(() => {
            console.log("Order status updated to served:", orderId);
            seenOrderIds.delete(orderId);
        }).catch((error) => {
            console.error("Error updating document:", error);
        });
      }

      // 3. Set timer to remove the order from the display after 3 seconds
      setTimeout(() => {
        orderDiv.classList.add("served");
        setTimeout(() => {
            orderDiv.remove();
        }, 500); // Wait for transition
      }, 3000);
    }
  </script>
</body>
</html>
