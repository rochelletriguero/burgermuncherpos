<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Burger Muncher POS</title>
  <style>
    /* Styling for a cleaner, modern look, and better touch targets */
    body { font-family: 'Inter', sans-serif; padding: 20px; max-width: 900px; /* Increased max width for side-by-side view */ margin: auto; background-color: #f4f7f6; color: #333; }
    h1 { text-align: center; color: #d9534f; margin-bottom: 25px; }
    
    /* NEW: Split Interface Container */
    .order-interface {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
    }
    .menu-container, .cart-container {
        flex: 1; /* Both take up equal space */
        min-width: 45%;
        padding: 15px; 
        background: white; 
        border-radius: 8px; 
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        /* Added max-height and overflow for the cart to control scrolling */
        max-height: 450px; 
        overflow-y: auto; 
    }
    /* Ensure containers stack on very small screens (phones) */
    @media (max-width: 600px) {
        .order-interface {
            flex-direction: column;
        }
        .menu-container, .cart-container {
            max-height: none; /* Let them expand vertically */
            overflow-y: visible;
        }
    }

    /* Menu Grid Styling */
    .menu-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
        gap: 8px;
    }
    .menu-button {
        padding: 10px 5px;
        background-color: #5cb85c; 
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 600;
        transition: background 0.2s;
        text-align: center;
        line-height: 1.2;
    }
    .menu-button:hover { background-color: #4cae4c; }

    /* Order Cart Table Styling */
    .cart-table { width: 100%; border-collapse: collapse; }
    .cart-table th, .cart-table td { padding: 8px 5px; text-align: left; border-bottom: 1px solid #ddd; font-size: 0.9em; }
    .cart-table th { background-color: #e9ecef; }
    .cart-item-row input[type="number"] {
        padding: 5px;
        font-size: 0.9em;
        width: 45px;
        text-align: center;
        box-sizing: border-box;
    }
    .cart-item-row input[type="text"] {
        padding: 5px;
        font-size: 0.85em;
        width: 95%;
        box-sizing: border-box;
        margin-top: 5px;
    }
    .cart-remove-button {
        background-color: #d9534f;
        color: white;
        border: none;
        padding: 5px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8em;
    }

    /* Existing styles from previous versions */
    .section { margin-bottom: 20px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05); }
    .total { font-size: 1.4em; font-weight: bold; text-align: right; padding: 5px 0; color: #333; }
    #total { color: #d9534f; }
    #change { color: #28a745; }
    label { display: block; margin-bottom: 8px; font-weight: 600; }
    .warning { color: #f0ad4e; font-weight: bold; margin-top: 5px; }
    .error { color: #d9534f; font-weight: bold; margin-top: 5px; }
    button { 
      width: 100%; 
      padding: 12px 20px; 
      font-size: 1.1em; 
      background: #d9534f; 
      color: white; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer; 
      transition: background 0.3s ease; 
      font-weight: 600;
    }
    button:hover { background: #c9302c; }
    #messageBox {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      background-color: #28a745;
      color: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transition: opacity 0.5s, transform 0.5s;
      z-index: 1000;
      font-weight: bold;
    }
    .radio-group label {
      display: inline-block;
      margin-right: 15px;
      font-weight: normal;
    }
    button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }
    .amount-paid-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
    }
    .amount-paid-buttons button {
        flex: 1 1 calc(33% - 8px); 
        padding: 10px 0;
        font-size: 1em;
        background-color: #f0ad4e; 
    }
    .amount-paid-buttons button:hover {
        background-color: #ec971f;
    }
    .discount-line {
        font-size: 1.1em; 
        font-weight: bold; 
        text-align: right; 
        padding: 5px 0; 
        color: #d9534f; 
    }

    /* === OFFLINE/SYNC INDICATOR STYLES === */
    .status-bar {
        position: sticky;
        top: 0;
        z-index: 900;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 15px;
        margin: -20px -20px 20px -20px; /* Cover body padding */
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        font-weight: 600;
        color: white;
    }
    .status-bar.online {
        background-color: #28a745; /* Green */
    }
    .status-bar.offline {
        background-color: #ffc107; /* Yellow/Warning */
        color: #333;
    }
    .sync-button {
        background: none;
        border: 1px solid white;
        color: white;
        padding: 4px 10px;
        border-radius: 4px;
        font-size: 0.9em;
        cursor: pointer;
        width: auto;
        transition: background 0.2s;
    }
    .status-bar.offline .sync-button {
        border-color: #333;
        color: #333;
    }
    .sync-button:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.2);
    }
    .sync-button:disabled {
        opacity: 0.7;
        cursor: wait;
    }


    /* === PRINT STYLES FOR KITCHEN TICKET (58mm) === */
    @media print {
        /* 1. Reset layout for receipt width (58mm) */
        body {
            max-width: 58mm !important; 
            padding: 5px;
            font-size: 10pt; 
            color: black !important;
            background: white !important;
        }
        
        /* 2. Hide all non-kitchen elements */
        .section, 
        .order-interface, 
        .menu-container, 
        #printOrderButton,
        #sendOrderButton,
        #messageBox,
        #userIdDisplay,
        #paymentError,
        #pwdWarning,
        .amount-paid-buttons,
        .status-bar, /* Hide the status bar when printing */
        /* Hide all financial/payment/discount info */
        .total, 
        .discount-line,
        /* Hide all quantity inputs and price display elements */
        .cart-table th:nth-child(4), .cart-table td:nth-child(4), /* Individual Price */
        .cart-table th:nth-child(5), .cart-table td:nth-child(5) /* Line Total */
        {
            display: none !important;
        }

        /* 3. Force display of the relevant sections */
        .cart-container {
            display: block !important;
            box-shadow: none;
            padding: 0;
            margin: 0;
            max-height: none;
            overflow: visible;
        }
        
        .cart-table {
            width: 100%;
        }
        
        /* Show Order Type & Customer Name container */
        .section:has(label[for="customerName"]),
        .section:has(input[name="orderType"]) {
            display: block !important;
            padding: 0 0 10px 0 !important;
            margin: 0 !important;
            box-shadow: none;
        }

        /* Custom Header Styling (Burnt Diner) */
        h1 {
            display: block !important;
            font-family: 'Georgia', sans-serif; /* Fallback for Museo Moderno */
            font-size: 12pt;
            font-weight: bold;
            text-align: center;
            margin-bottom: 5px;
            color: black !important;
        }

        /* Styling for Item List */
        .cart-table th, .cart-table td {
            padding: 2px 0;
            border-bottom: none; 
            font-size: 10pt;
        }
        
        /* Hide 'X' remove button column */
        .cart-table th:nth-child(1), .cart-table td:nth-child(1) { display: none; } 
        
        /* Item Name and Note Formatting */
        .cart-item-row strong { 
            display: block; 
            font-size: 11pt;
            font-weight: bold;
        }
        .cart-item-row input[type="text"] {
            border: none !important;
            padding: 0;
            margin: 0 0 5px 0;
            width: 100% !important;
            font-size: 10pt;
            font-style: italic;
            color: #555;
            display: block;
        }
        .cart-item-row input[type="number"] {
            display: none; /* Hide number input */
        }
        .cart-table th:nth-child(2), .cart-table td:nth-child(2) {
             /* Qty column width is preserved for simplicity, we'll rely on text to show QTY */
             text-align: left;
        }
        
        /* Add a simple text representation of QTY instead of the input box */
        .cart-item-row td:nth-child(2)::before {
            content: attr(data-qty-value) "x";
            font-weight: bold;
            display: block;
        }

        /* Ensure Order Type and Customer Name labels are clean */
        .section label[for="customerName"],
        .section label:has(input[name="orderType"]) {
            display: block !important;
            font-size: 10pt;
            font-weight: bold;
            margin-bottom: 2px;
            padding: 0;
        }
        
        /* Ensure the Order Type and Customer Name values are printed */
        .section input[type="text"],
        .section input[type="radio"]:checked + label {
            display: inline-block !important;
            font-weight: normal;
            font-size: 10pt;
            border: none;
            padding: 0;
            margin: 0;
        }
        
        /* Hide all radio buttons/checkboxes/inputs not in the cart */
        input:not(.cart-item-row input),
        .radio-group {
            display: none !important;
        }
    }
  /* === CLEAN RECEIPT TEMPLATE (non-destructive to UI) === */
#printArea .receipt{
  width:58mm; max-width:58mm; min-width:58mm;
  padding:6px 6px 10px;
  color:#000; background:#fff;
  font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, "Liberation Mono", monospace;
  font-size:11px; line-height:1.35;
}
.rc-center{text-align:center}
.rc-strong{font-weight:700}
.rc-muted{color:#444}
.rc-row{display:flex; justify-content:space-between; gap:10px}
.rc-divider{border-top:1px dashed #000; margin:6px 0}
.rc-items{margin-top:6px}
.rc-item{margin:2px 0}
.rc-item-header{display:flex; justify-content:space-between}
.rc-item-name{max-width:34mm; word-wrap:break-word}
.rc-note{margin-left:10px; color:#444; font-style:italic}

@media print{
  @page{ margin:4mm }
  /* Only show the receipt during print */
  #appRoot{ display:none !important; }
  #printArea{ display:block !important; }
}

/* === MINIMAL KITCHEN TICKET (tight) === */
#printArea .receipt{
  width:58mm; max-width:58mm; min-width:58mm;
  padding:4px 4px 6px;
  color:#000; background:#fff;
  font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, "Liberation Mono", monospace;
  font-size:11px; line-height:1.2;
  white-space:pre-line; /* keep our \n line breaks */
}
.tk-line{ margin:0; padding:0; }
@media print{
  @page{ margin:3mm }
  /* Only show the receipt during print */
  #appRoot{ display:none !important; }
  #printArea{ display:block !important; }
}
</style>
</head>
<body>
  <div id="appRoot">
  <div id="messageBox"></div>

  <div id="statusBar" class="status-bar offline">
    <span id="statusText">Offline Mode</span>
    <button id="syncButton" class="sync-button" onclick="syncOrders()">
        Sync (<span id="pendingOrdersCount">0</span>)
    </button>
  </div>
  
  <h1 id="mainHeader">Burnt Diner</h1>

  <div class="section">
    <label for="customerName">Customer Name</label>
    <input type="text" id="customerName" placeholder="Enter name" />
  </div>

  <div class="order-interface">
    
    <div class="cart-container">
        <h2>Current Order</h2>
        <table class="cart-table">
            <thead>
                <tr>
                    <th style="width: 5%;">X</th>
                    <th style="width: 10%;">Qty</th>
                    <th style="width: 40%;">Item/Note</th>
                    <th style="width: 15%;">Price</th>
                    <th style="width: 15%; text-align: right;">Total</th>
                </tr>
            </thead>
            <tbody id="orderCart">
                </tbody>
        </table>
        <div id="emptyCartMessage" style="text-align: center; color: #6c757d; padding: 10px;">Cart is empty.</div>
    </div>

    <div class="menu-container">
        <h2>Menu Selection</h2>
        <div id="menuButtons"></div>
    </div>
  </div>
  <div class="section">
    <label>PWD Discount Options (20% Off)</label>
    <div class="radio-group" onchange="updateSubtotal()">
      <label><input type="radio" name="pwdDiscount" value="None" checked /> **No Discount**</label>
      <label><input type="radio" name="pwdDiscount" value="HighestItem" /> Highest Priced Item Only (Shared Meal)</label>
      <label><input type="radio" name="pwdDiscount" value="WholeOrder" /> Whole Order (One Person)</label>
    </div>
    <div id="pwdWarning" class="warning" style="display:none;">‚ö†Ô∏è Whole Order Discount applied with multiple items. Confirm eligibility.</div>
  </div>

  <div class="total">Subtotal: ‚Ç±<span id="subtotal">0</span></div>
  <div class="discount-line">Discount Applied: ‚Ç±<span id="discountApplied">0</span></div>
  <div class="total">Total after Discount: ‚Ç±<span id="total">0</span></div>

  <div class="section">
    <label>Order Type</label>
    <div class="radio-group">
      <label><input type="radio" name="orderType" value="Dine In" checked /> Dine In</label>
      <label><input type="radio" name="orderType" value="Take Out" /> Take Out</label>
    </div>
  </div>

  <div class="section">
    <label>Payment Method</label>
    <div class="radio-group">
      <label><input type="radio" name="paymentMethod" value="Cash" checked /> Cash</label>
      <label><input type="radio" name="paymentMethod" value="GCash" /> GCash</label>
    </div>
  </div>
  
  <div class="section">
    <label for="amountPaid">Amount Paid</label>
    <input type="number" id="amountPaid" min="0" value="0" onchange="updateSubtotal()" />
    
    <div class="amount-paid-buttons">
        <button onclick="appendAmount(200)">‚Ç±200</button>
        <button onclick="appendAmount(300)">‚Ç±300</button>
        <button onclick="appendAmount(400)">‚Ç±400</button>
        <button onclick="appendAmount(500)">‚Ç±500</button>
        <button onclick="appendAmount(1000)">‚Ç±1000</button>
        <button onclick="appendAmount('clear')">Clear</button>
    </div>
    
    <div class="total">Change: ‚Ç±<span id="change">0</span></div>
    <div id="paymentError" class="error" style="display:none;">‚ö†Ô∏è Amount paid is less than total.</div>
  </div>
  
  <div class="section">
    <div style="font-size: 0.8em; margin-bottom: 10px; color: #6c757d;">
      User ID: <span id="userIdDisplay">Initializing...</span>
    </div>
    <button id="printOrderButton" onclick="printReceipt()" style="background: #337ab7; margin-bottom: 10px;">üñ®Ô∏è Print Kitchen Ticket</button>
    <button id="sendOrderButton" onclick="sendOrder()">üì§ Send Order & Save</button>
  </div>

  <script type="module">
    // --- Firebase SDK Imports ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, addDoc, collection, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    setLogLevel('Debug');

    // --- Global Variables ---
    let db, auth;
    let currentUserId = null;
    let appId = 'default-app-id';
    let isOnline = navigator.onLine; // Initial online status

    // --- IndexedDB Setup ---
    const DB_NAME = 'OfflinePOSDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'pendingOrders';
    let dbInstance = null;
    
    function openDatabase() {
        return new Promise((resolve, reject) => {
            if (dbInstance) {
                return resolve(dbInstance);
            }
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                }
            };

            request.onsuccess = (event) => {
                dbInstance = event.target.result;
                console.log("IndexedDB opened successfully.");
                resolve(dbInstance);
                // After opening, check for pending orders
                updatePendingOrdersCount(); 
            };

            request.onerror = (event) => {
                console.error("IndexedDB error:", event.target.error);
                reject(event.target.error);
            };
        });
    }

    // Function to save an order to IndexedDB
    async function saveOrderToIndexedDB(orderData) {
        try {
            const db = await openDatabase();
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            
            // Add a unique ID for IndexedDB and a timestamp for sorting
            const indexedDBOrder = {
                ...orderData,
                offlineTimestamp: Date.now(),
                // 'id' property is added by autoIncrement
            };
            
            await new Promise((resolve, reject) => {
                const request = store.add(indexedDBOrder);
                request.onsuccess = () => resolve();
                request.onerror = (e) => reject(e);
            });
            
            updatePendingOrdersCount();
            return true;
        } catch (e) {
            console.error("Failed to save order to IndexedDB:", e);
            return false;
        }
    }
    
    // Function to get all pending orders from IndexedDB
    async function getPendingOrders() {
        try {
            const db = await openDatabase();
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            
            return await new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (e) => reject(e);
            });
        } catch (e) {
            console.error("Failed to retrieve pending orders:", e);
            return [];
        }
    }

    // Function to delete a specific order from IndexedDB
    async function deleteOrderFromIndexedDB(id) {
        try {
            const db = await openDatabase();
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            
            await new Promise((resolve, reject) => {
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = (e) => reject(e);
            });
            updatePendingOrdersCount();
            return true;
        } catch (e) {
            console.error("Failed to delete order from IndexedDB:", e);
            return false;
        }
    }
    
    // Function to update the pending orders count in the UI
    async function updatePendingOrdersCount() {
        const orders = await getPendingOrders();
        document.getElementById("pendingOrdersCount").textContent = orders.length;
        document.getElementById("syncButton").disabled = orders.length === 0 || !isOnline;
    }

    // --- Firebase Initialization (Modified for safety) ---
    const defaultFirebaseConfig = { 
        apiKey: "AIzaSyDhofFG3SN-q3l4n4udHv7tOWT6ewb9aQ8", 
        authDomain: "burnt-pos.firebaseapp.com", 
        projectId: "burnt-pos", 
        storageBucket: "burnt-pos.firebasestorage.app", 
        messagingSenderId: "186475223375", 
        appId: "1:186475223375:web:0ecf0136f9af26985a8d3a", 
        measurementId: "G-NWTNRQ3GCM" 
    };

    let firebaseConfig;

    try {
        firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : defaultFirebaseConfig;
        appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    } catch (e) {
        console.error("Error parsing __firebase_config, using default.", e);
        firebaseConfig = defaultFirebaseConfig;
    }

    const app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    auth = getAuth(app);
    
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        currentUserId = user.uid;
        document.getElementById("userIdDisplay").textContent = currentUserId;
        console.log("User signed in:", currentUserId);
        // listenToOrders(); // Disabled listening to historical orders for simplicity
      } else {
        try {
            if (typeof __initial_auth_token !== 'undefined') {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Firebase Auth Error:", error);
            document.getElementById("userIdDisplay").textContent = "Auth Error";
        }
      }
    });
    
    // --- Network Status Handlers ---
    const statusBar = document.getElementById("statusBar");
    const statusText = document.getElementById("statusText");

    function updateNetworkStatus() {
        isOnline = navigator.onLine;
        if (isOnline) {
            statusBar.classList.remove('offline');
            statusBar.classList.add('online');
            statusText.textContent = "Online Mode (Ready to Sync)";
            // Attempt auto-sync when back online
            syncOrders(); 
        } else {
            statusBar.classList.remove('online');
            statusBar.classList.add('offline');
            statusText.textContent = "Offline Mode (Saving to Local Storage)";
        }
        updatePendingOrdersCount(); // Re-evaluate sync button state
    }

    window.addEventListener('online', updateNetworkStatus);
    window.addEventListener('offline', updateNetworkStatus);
    // Initial call is handled by initializeApp now
    // updateNetworkStatus(); 

    // --- Synchronization Function ---
    window.syncOrders = async function() {
        if (!isOnline || !currentUserId) {
            showMessage("Cannot sync: Must be online and authenticated.", true);
            return;
        }

        const syncButton = document.getElementById("syncButton");
        syncButton.disabled = true;
        syncButton.textContent = "Syncing...";
        
        const orders = await getPendingOrders();
        let successCount = 0;
        let failCount = 0;

        if (orders.length === 0) {
            showMessage("No pending orders to sync.", false);
            syncButton.textContent = `Sync (${successCount})`;
            syncButton.disabled = true;
            return;
        }
        
        const orderCollectionRef = collection(db, `artifacts/${appId}/public/data/orders`);
        
        for (const order of orders) {
            try {
                // Remove the IndexedDB ID before sending to Firestore
                const { id, ...fireStoreOrder } = order; 
                
                // Firestore automatically provides a serverTimestamp, but we use the
                // offlineTimestamp as the client-side time of creation for accuracy.
                // We must manually add the serverTimestamp property for Firestore.
                fireStoreOrder.createdAt = serverTimestamp();
                fireStoreOrder.offlineTime = order.offlineTimestamp; 
                
                await addDoc(orderCollectionRef, fireStoreOrder);
                await deleteOrderFromIndexedDB(id);
                successCount++;
            } catch (e) {
                console.error(`Failed to sync order ID ${order.id}:`, e);
                failCount++;
                // Stop syncing if the error is due to authentication or permissions
                if (e.code === 'permission-denied' || e.code === 'unauthenticated') {
                    showMessage("Sync failed: Authentication error. Try logging in again.", true);
                    break; 
                }
            }
        }
        
        syncButton.textContent = `Sync (${failCount})`;
        
        if (failCount > 0) {
            showMessage(`‚ö†Ô∏è Sync finished: ${successCount} orders sent, ${failCount} failed.`, true);
        } else {
            showMessage(`‚úÖ Sync complete! ${successCount} orders sent successfully.`, false);
        }
        
        await updatePendingOrdersCount();
        syncButton.disabled = failCount > 0 || await getPendingOrders().length === 0;
    }
    
    // --- POS Application Logic (Unchanged Menu/Calculations) ---

    const menuSections = [
      {
        icon: "üçî",
        name: "Burgers",
        items: [
          { code: "B1", name: "Single Burnt", price: 129 },
          { code: "B2", name: "Double Burnt", price: 179 },
          { code: "B3", name: "Single BLT", price: 159 },
          { code: "B4", name: "Double BLT", price: 209 },
          { code: "BU", name: "Upgrade", price: 69 }
        ]
      },
      {
        icon: "üçü",
        name: "Fries",
        items: [
          { code: "F1", name: "Chonky Fries", price: 69 }
        ]
      },
      {
        icon: "üßá",
        name: "All-Day Munchies",
        items: [
          { code: "A1", name: "Chicken & Waffles", price: 199 },
          { code: "A2", name: "Brunch Plate", price: 169 }
        ]
      },
      {
        icon: "ü•§",
        name: "Milk Shakes",
        items: [
          { code: "MS1", name: "Vanilla Milk Shake", price: 119 }, 
          { code: "MS2", name: "Chocolate Milk Shake", price: 119 }, 
          { code: "MS3", name: "Strawberry Milk Shake", price: 119 }
        ]
      },
      {
        icon: "üßä",
        name: "Drinks",
        items: [
          { code: "D1", name: "House Blend Iced Tea", price: 35 },
          { code: "D2", name: "Sodas", price: 25 }
        ]
      }
    ];

    // Combine all items into a map for quick lookup
    const menuItemsMap = new Map(menuSections.flatMap(section => section.items).map(item => [item.code, item]));
    
    // Global variable to track the unique ID for each cart item (for easy removal/update)
    let cartItemCounter = 0;


    const subtotalDisplay = document.getElementById("subtotal");
    const discountAppliedDisplay = document.getElementById("discountApplied"); 
    const totalDisplay = document.getElementById("total");
    const changeDisplay = document.getElementById("change");
    const pwdWarning = document.getElementById("pwdWarning");
    const paymentError = document.getElementById("paymentError");
    const messageBox = document.getElementById("messageBox");
    const amountPaidInput = document.getElementById("amountPaid");
    const orderCartBody = document.getElementById("orderCart");
    const emptyCartMessage = document.getElementById("emptyCartMessage");


    // Helper function to show a temporary message
    function showMessage(msg, isError = false) {
      messageBox.textContent = msg;
      messageBox.style.backgroundColor = isError ? '#dc3545' : '#28a745';
      messageBox.style.opacity = 1;
      messageBox.style.transform = 'translateX(-50%) translateY(0)';
      
      setTimeout(() => {
        messageBox.style.opacity = 0;
        messageBox.style.transform = 'translateX(-50%) translateY(-20px)';
      }, 3000);
    }
    
    // Function to quickly set Amount Paid
    window.appendAmount = function(amount) {
        if (amount === 'clear') {
            amountPaidInput.value = 0;
        } else {
            amountPaidInput.value = amount;
        }
        updateSubtotal();
    }

    // Function to trigger browser print
    window.printReceipt = function() {
        // Before printing, update the cart rows with the current quantity value 
        const cartRows = document.querySelectorAll(".cart-item-row");
        cartRows.forEach(row => {
            const uniqueId = row.getAttribute("data-item-id");
            const qty = document.querySelector(`[data-input-id="qty-${uniqueId}"]`).value;
            row.children[1].setAttribute('data-qty-value', qty); 
        });
        
        window.print();
    }
    
    // Function to add an item to the cart
    window.addItemToCart = function(itemCode) {
        const item = menuItemsMap.get(itemCode);
        if (!item) return;

        cartItemCounter++;
        const uniqueId = `cart-${cartItemCounter}`;

        const itemRow = document.createElement("tr");
        itemRow.classList.add("cart-item-row");
        itemRow.setAttribute("data-item-id", uniqueId);
        itemRow.setAttribute("data-item-code", item.code); 
        itemRow.setAttribute("data-price", item.price);

        itemRow.innerHTML = `
            <td><button class="cart-remove-button" onclick="removeItemFromCart('${uniqueId}')">X</button></td>
            <td>
                <input type="number" min="1" value="1" onchange="updateSubtotal()" data-input-id="qty-${uniqueId}" />
            </td>
            <td>
                <strong>${item.name} (${item.code})</strong><br>
                <input type="text" placeholder="Note (e.g., No onions)" onchange="updateSubtotal()" data-input-id="note-${uniqueId}" />
            </td>
            <td>‚Ç±${item.price}</td>
            <td style="text-align: right;">‚Ç±<span data-display-id="total-${uniqueId}">${item.price}</span></td>
        `;

        orderCartBody.appendChild(itemRow);
        updateCartDisplay(); 
        updateSubtotal();
    }
    
    // Function to remove an item from the cart
    window.removeItemFromCart = function(uniqueId) {
        const itemRow = document.querySelector(`[data-item-id="${uniqueId}"]`);
        if (itemRow) {
            itemRow.remove();
            updateCartDisplay();
            updateSubtotal();
        }
    }

    // Function to update the visibility of the "Cart is empty" message
    function updateCartDisplay() {
        if (orderCartBody.children.length === 0) {
            emptyCartMessage.style.display = 'block';
        } else {
            emptyCartMessage.style.display = 'none';
        }
    }


    // Function to calculate and update totals
    window.updateSubtotal = function() {
      let subtotal = 0;
      let totalQty = 0;
      let discountAmount = 0;
      let highestItemTotal = 0;
      
      const cartRows = document.querySelectorAll(".cart-item-row");
      const discountMethod = document.querySelector('input[name="pwdDiscount"]:checked').value;
      
      // Early exit if no items are in the cart
      if (cartRows.length === 0) {
          subtotalDisplay.textContent = '0';
          discountAppliedDisplay.textContent = '0';
          totalDisplay.textContent = '0';
          changeDisplay.textContent = '0';
          pwdWarning.style.display = "none";
          document.getElementById("sendOrderButton").disabled = true;
          return; 
      }

      // 1. Calculate Subtotal, Total Quantity, and find Highest Priced Item Total
      cartRows.forEach(row => {
        const uniqueId = row.getAttribute("data-item-id");
        const price = parseFloat(row.getAttribute("data-price"));
        // Get quantity from the dynamically created input
        const qty = parseInt(document.querySelector(`[data-input-id="qty-${uniqueId}"]`).value) || 0;
        
        const lineTotal = price * qty;
        subtotal += lineTotal;
        totalQty += qty;
        
        if (lineTotal > highestItemTotal) {
            highestItemTotal = lineTotal;
        }
        
        // Update the line total display
        document.querySelector(`[data-display-id="total-${uniqueId}"]`).textContent = lineTotal.toFixed(0);
      });

      // 2. Apply Discount Logic
      if (discountMethod === "WholeOrder") {
        discountAmount = subtotal * 0.20;
        // Show warning if Whole Order Discount is applied with multiple items
        pwdWarning.style.display = totalQty > 1 ? "block" : "none";
      } else if (discountMethod === "HighestItem") {
        discountAmount = highestItemTotal * 0.20;
        pwdWarning.style.display = "none"; 
      } else { // "None"
        discountAmount = 0;
        pwdWarning.style.display = "none";
      }
      
      // Round discount and calculate final total
      discountAmount = Math.round(discountAmount); 
      let total = subtotal - discountAmount;
      
      // 3. Update Displays
      subtotalDisplay.textContent = subtotal.toFixed(0);
      discountAppliedDisplay.textContent = discountAmount.toFixed(0);
      totalDisplay.textContent = total.toFixed(0);

      const amountPaid = parseFloat(document.getElementById("amountPaid").value) || 0;
      const change = amountPaid - total;
      changeDisplay.textContent = change >= 0 ? change.toFixed(0) : 0;
      paymentError.style.display = change < 0 ? "block" : "none";
      
      // Prevent order if payment is insufficient or total is zero (empty cart)
      document.getElementById("sendOrderButton").disabled = change < 0 || total === 0;
    }

    // Function to send the order (UPDATED: Uses IndexedDB when offline)
    window.sendOrder = async function() {
      if (!currentUserId) {
        showMessage("System initializing. Please wait for authentication.", true);
        return;
      }
      
      const cartRows = document.querySelectorAll(".cart-item-row");
      if (cartRows.length === 0) {
        showMessage("Please add items to the order.", true);
        return;
      }

      const customerName = document.getElementById("customerName").value.trim() || "N/A";
      const orderType = document.querySelector('input[name="orderType"]:checked').value;
      const paymentMethod = document.querySelector('input[name="paymentMethod"]:checked').value;
      const amountPaid = parseFloat(document.getElementById("amountPaid").value) || 0;
      const total = parseInt(document.getElementById("total").textContent);
      const change = parseInt(document.getElementById("change").textContent);
      
      const discountMethod = document.querySelector('input[name="pwdDiscount"]:checked').value;
      const discountAmount = parseInt(document.getElementById("discountApplied").textContent);

      // Collect items, quantities, and line item notes from the cart
      const items = [];
      cartRows.forEach(row => {
        const uniqueId = row.getAttribute("data-item-id");
        const itemCode = row.getAttribute("data-item-code");
        const itemPrice = parseFloat(row.getAttribute("data-price"));
        
        const qtyInput = document.querySelector(`[data-input-id="qty-${uniqueId}"]`);
        const noteInput = document.querySelector(`[data-input-id="note-${uniqueId}"]`);
        
        const qty = parseInt(qtyInput.value) || 0;
        const note = noteInput.value.trim();
        const itemName = menuItemsMap.get(itemCode).name;
        
        if (qty > 0) {
            items.push({ 
                code: itemCode, 
                name: itemName, 
                qty, 
                price: itemPrice,
                note: note
            });
        }
      });
      
      if (items.length === 0) {
          showMessage("Please add items to the order.", true);
          return;
      }

      if (total > amountPaid) {
          showMessage("Payment amount is insufficient.", true);
          return;
      }

      const orderData = {
        customerName,
        orderType,
        paymentMethod,
        amountPaid: amountPaid, 
        total: total,
        change: change,
        discountType: discountMethod,
        discountAmount: discountAmount,
        items, 
        status: isOnline ? 'saved' : 'pending_offline', // Track status
        createdBy: currentUserId
      };

      let saveSuccess = false;
      
      if (isOnline) {
        // ONLINE: Send directly to Firestore
        try {
            const orderCollectionRef = collection(db, `artifacts/${appId}/public/data/orders`);
            // Add serverTimestamp for creation time
            orderData.createdAt = serverTimestamp(); 
            await addDoc(orderCollectionRef, orderData);
            
            showMessage(`‚úÖ Order for ${customerName} saved successfully to Firestore!`, false);
            saveSuccess = true;
        } catch (e) {
            console.error("Error adding document to Firestore. Falling back to offline save:", e);
            showMessage("‚ùå Failed to save online. Saving to local storage instead.", true);
            // Fallback to offline if online save fails
            saveSuccess = await saveOrderToIndexedDB(orderData);
        }
      } else {
        // OFFLINE: Save to IndexedDB
        saveSuccess = await saveOrderToIndexedDB(orderData);
        if (saveSuccess) {
            showMessage(`‚úÖ Order for ${customerName} saved locally. Sync when online!`, false);
        } else {
            showMessage("‚ùå Failed to save order locally. Service unavailable.", true);
        }
      }

      if (saveSuccess) {
          // Reset form on successful save (online or offline)
          document.getElementById("customerName").value = "";
          document.getElementById("amountPaid").value = "0";
          document.querySelector('input[name="pwdDiscount"][value="None"]').checked = true; 
          document.querySelector('input[name="orderType"][value="Dine In"]').checked = true;
          document.querySelector('input[name="paymentMethod"][value="Cash"]').checked = true;
          
          // Clear the cart
          orderCartBody.innerHTML = "";
          updateCartDisplay();
          updateSubtotal(); 
      }
    }
    
    // Original listener function (kept but unused for the scope of offline sync)
    function listenToOrders() {
        /*
        const orderCollectionRef = collection(db, `artifacts/${appId}/public/data/orders`);
        const q = query(orderCollectionRef, limit(5));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
                const order = change.doc.data();
                if (change.type === "added") {
                    console.log("New Order Added:", order.customerName, order.total);
                }
            });
        }, (error) => {
            console.error("Error listening to orders:", error);
        });
        */
    }

    // Initialize Menu Buttons
    function initializeMenuButtons() {
        console.log("Initializing Menu Buttons..."); 
        const menuButtonsDiv = document.getElementById("menuButtons");
        if (!menuButtonsDiv) {
            console.error("DOM element #menuButtons not found. Cannot initialize menu.");
            return;
        }

        menuButtonsDiv.innerHTML = ""; 

        menuSections.forEach(section => {
            // Create a heading for each section
            const sectionHeader = document.createElement("h3");
            sectionHeader.textContent = `${section.icon} ${section.name}`;
            sectionHeader.style.cssText = "margin-top: 15px; margin-bottom: 5px; color: #d9534f; border-bottom: 1px solid #eee;";
            menuButtonsDiv.appendChild(sectionHeader);

            // Create a grid container for the items in the section
            const grid = document.createElement("div");
            grid.classList.add("menu-grid");

            section.items.forEach(item => {
                const button = document.createElement("button");
                button.classList.add("menu-button");
                button.textContent = `${item.code} - ${item.name} (‚Ç±${item.price})`;
                button.onclick = () => addItemToCart(item.code); 
                grid.appendChild(button);
            });
            menuButtonsDiv.appendChild(grid);
        });
        console.log("Menu Buttons initialized successfully.");
    }

    // Core app setup logic (excluding menu buttons)
    function initializeAppCore() {
        console.log("Starting POS App Core initialization.");
        updateCartDisplay();
        updateSubtotal();
        updateNetworkStatus(); 
        openDatabase(); 
    }
    
    // --- FINAL Initialization: Prioritize Menu and then run Core App Logic ---
    window.addEventListener('DOMContentLoaded', () => {
        initializeMenuButtons(); 
        initializeAppCore();
    });
  </script>
  </div>

  <!-- PRINT-ONLY AREA -->
  <div id="printArea" style="display:none">
    <div class="receipt" id="receipt"></div>
  </div>

<script>
// This block handles the print receipt generation logic (Kitchen Ticket)
(function(){
  function peso(n){ return `‚Ç±${Number(n).toFixed(0)}`; }
  function esc(s){ return String(s||'').replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m])); }

  function buildReceipt(){
    const receipt = document.getElementById('receipt');
    if(!receipt) return;

    // Get inputs
    const rawName = (document.getElementById('customerName')?.value || 'Walk-in').trim();
    const name = rawName || 'Walk-in';
    const orderType = ((document.querySelector('input[name="orderType"]:checked')||{}).value || 'Dine In').toUpperCase();

    // Collect items
    const rows = Array.from(document.querySelectorAll('.cart-item-row')).map(row => {
      const id = row.getAttribute('data-item-id') || '';
      const qtyEl = document.querySelector(`[data-input-id="qty-${id}"]`) || row.querySelector('input[type="number"]');
      const noteEl = document.querySelector(`[data-input-id="note-${id}"]`) || row.parentElement?.querySelector(`[data-input-id="note-${id}"]`);

      const qty = parseInt(qtyEl?.value || '0', 10);
      // Extract name from <strong> but strip trailing " (CODE)"
      let nm = row.querySelector('td:nth-child(3) strong')?.textContent?.trim() || 'Item';
      nm = nm.replace(/\s*\([A-Za-z0-9]+\)\s*$/, ''); // remove codes like (B1)
      const note = (noteEl?.value || '').trim();
      return { qty, name:nm, note };
    }).filter(x => x.qty > 0);

    // Compose minimal ticket (tightest: no blank lines, uppercase labels)
    let lines = [];
    lines.push(`CUSTOMER: ${name}`);
    lines.push(`ORDER TYPE: ${orderType}`);
    // No blank line per user's choice

    rows.forEach(r => {
      const notePart = r.note ? ` ‚Ä¢ ${r.note}` : '';
      lines.push(`${r.qty} x ${r.name}${notePart}`);
    });

    receipt.textContent = lines.join('\n');}

  // Safely override after page scripts have defined the original function
  const onReady = () => {
    const orig = window.printReceipt;
    window._origPrintReceipt = orig;
    window.printReceipt = function(){
      try { buildReceipt(); } catch(e){ console.error('buildReceipt failed', e); }
      window.print();
    };
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', onReady);
  } else {
    onReady();
  }
})();
</script>

</body>
</html>
