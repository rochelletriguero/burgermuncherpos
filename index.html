<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Burger Muncher POS</title>
  <style>
    /* Styling for a cleaner, modern look, and better touch targets */
    body { font-family: 'Inter', sans-serif; padding: 20px; max-width: 900px; /* Increased max width for side-by-side view */ margin: auto; background-color: #f4f7f6; color: #333; }
    h1 { text-align: center; color: #d9534f; margin-bottom: 25px; }
    
    /* NEW: Split Interface Container */
    .order-interface {
        display: flex;
        gap: 20px;
        margin-bottom: 20px;
    }
    .menu-container, .cart-container {
        flex: 1; /* Both take up equal space */
        min-width: 45%;
        padding: 15px; 
        background: white; 
        border-radius: 8px; 
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
        /* Added max-height and overflow for the cart to control scrolling */
        max-height: 450px; 
        overflow-y: auto; 
    }
    /* Ensure containers stack on very small screens (phones) */
    @media (max-width: 600px) {
        .order-interface {
            flex-direction: column;
        }
        .menu-container, .cart-container {
            max-height: none; /* Let them expand vertically */
            overflow-y: visible;
        }
    }

    /* Menu Grid Styling */
    .menu-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
        gap: 8px;
    }
    .menu-button {
        padding: 10px 5px;
        background-color: #5cb85c; 
        color: white;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 600;
        transition: background 0.2s;
        text-align: center;
        line-height: 1.2;
    }
    .menu-button:hover { background-color: #4cae4c; }

    /* Order Cart Table Styling */
    .cart-table { width: 100%; border-collapse: collapse; }
    .cart-table th, .cart-table td { padding: 8px 5px; text-align: left; border-bottom: 1px solid #ddd; font-size: 0.9em; }
    .cart-table th { background-color: #e9ecef; }
    .cart-item-row input[type="number"] {
        padding: 5px;
        font-size: 0.9em;
        width: 45px;
        text-align: center;
        box-sizing: border-box;
    }
    .cart-item-row input[type="text"] {
        padding: 5px;
        font-size: 0.85em;
        width: 95%;
        box-sizing: border-box;
        margin-top: 5px;
    }
    .cart-remove-button {
        background-color: #d9534f;
        color: white;
        border: none;
        padding: 5px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8em;
    }
    .cart-modify-button { /* NEW STYLE */
        background-color: #007bff; /* Blue for modify */
        color: white;
        border: none;
        padding: 5px 8px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.8em;
    }

    /* Existing styles from previous versions */
    .section { margin-bottom: 20px; padding: 15px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05); }
    .total { font-size: 1.4em; font-weight: bold; text-align: right; padding: 5px 0; color: #333; }
    #total { color: #d9534f; }
    #change { color: #28a745; }
    label { display: block; margin-bottom: 8px; font-weight: 600; }
    .warning { color: #f0ad4e; font-weight: bold; margin-top: 5px; }
    .error { color: #d9534f; font-weight: bold; margin-top: 5px; }
    button { 
      width: 100%; 
      padding: 12px 20px; 
      font-size: 1.1em; 
      background: #d9534f; 
      color: white; 
      border: none; 
      border-radius: 8px; 
      cursor: pointer; 
      transition: background 0.3s ease; 
      font-weight: 600;
    }
    button:hover { background: #c9302c; }
    #messageBox {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      padding: 15px 30px;
      background-color: #28a745;
      color: white;
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      opacity: 0;
      transition: opacity 0.5s, transform 0.5s;
      z-index: 1000;
      font-weight: bold;
    }
    .radio-group label {
      display: inline-block;
      margin-right: 15px;
      font-weight: normal;
    }
    button:disabled {
        background-color: #cccccc;
        cursor: not-allowed;
    }
    .amount-paid-buttons {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
    }
    .amount-paid-buttons button {
        flex: 1 1 calc(33% - 8px); 
        padding: 10px 0;
        font-size: 1em;
        background-color: #f0ad4e; 
    }
    .amount-paid-buttons button:hover {
        background-color: #ec971f;
    }
    .discount-line {
        font-size: 1.1em; 
        font-weight: bold; 
        text-align: right; 
        padding: 5px 0; 
        color: #d9534f; 
    }

    /* === OFFLINE/SYNC INDICATOR STYLES === */
    .status-bar {
        position: sticky;
        top: 0;
        z-index: 900;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 15px;
        margin: -20px -20px 20px -20px; /* Cover body padding */
        border-bottom-left-radius: 8px;
        border-bottom-right-radius: 8px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        font-weight: 600;
        color: white;
    }
    .status-bar.online {
        background-color: #28a745; /* Green */
    }
    .status-bar.offline {
        background-color: #ffc107; /* Yellow/Warning */
        color: #333;
    }
    .sync-button {
        background: none;
        border: 1px solid white;
        color: white;
        padding: 4px 10px;
        border-radius: 4px;
        font-size: 0.9em;
        cursor: pointer;
        width: auto;
        transition: background 0.2s;
    }
    .status-bar.offline .sync-button {
        border-color: #333;
        color: #333;
    }
    .sync-button:hover:not(:disabled) {
        background: rgba(255, 255, 255, 0.2);
    }
    .sync-button:disabled {
        opacity: 0.7;
        cursor: wait;
    }

    /* === MODAL STYLES === */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        display: none; /* Hidden by default */
        justify-content: center;
        align-items: center;
        z-index: 1050;
    }
    .modal-content {
        background: white;
        padding: 25px;
        border-radius: 10px;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        max-height: 90vh; 
        overflow-y: auto; 
    }
    .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid #eee;
        padding-bottom: 10px;
        margin-bottom: 15px;
    }
    .modal-header h3 {
        margin: 0;
        color: #d9534f;
    }
    .modal-close {
        background: none;
        border: none;
        font-size: 1.5em;
        cursor: pointer;
        color: #aaa;
        padding: 0;
        width: 30px;
    }
    .modification-group {
        border: 1px solid #eee;
        padding: 10px;
        margin-bottom: 10px;
        border-radius: 4px;
    }
    .modification-group label {
        font-weight: bold;
        display: block;
        margin-bottom: 5px;
    }
    .modification-group input[type="radio"], .modification-group select {
        margin-right: 5px;
    }
    .modal-actions {
        margin-top: 20px;
        display: flex;
        gap: 10px;
    }
    .modal-actions button {
        width: auto;
        flex: 1;
    }

    /* === PRINT STYLES FOR KITCHEN TICKET (58mm) - Clean Text Composition === */
    @media print {
        /* 1. Reset layout for receipt width (58mm) */
        body {
            max-width: 58mm !important; 
            padding: 5px;
            font-size: 10pt; 
            color: black !important;
            background: white !important;
        }
        @page { margin: 3mm; } /* Tighter margins for 58mm printer */
        
        /* 2. Hide everything in the main app, show only the print area */
        #appRoot, 
        .order-interface,
        .total, 
        .discount-line,
        .section,
        h1
        {
            display: none !important;
        }
        
        #printArea {
            display: block !important;
            box-shadow: none;
            padding: 0;
            margin: 0;
            max-height: none;
            overflow: visible;
        }

        /* 3. Style the hidden receipt div to look like a ticket */
        #printArea .receipt {
            display: block !important;
            width: 58mm; 
            max-width: 58mm; 
            min-width: 58mm;
            padding: 4px 4px 6px;
            color: #000; 
            background: #fff;
            font-family: ui-monospace, "SFMono-Regular", Menlo, Consolas, "Liberation Mono", monospace;
            font-size: 11px; 
            line-height: 1.2;
            white-space: pre-line; /* keeps the \n line breaks from JS */
        }
    }
  </style>
</head>
<body>
  <div id="appRoot">
  <div id="messageBox"></div>

  <div id="statusBar" class="status-bar offline">
    <span id="statusText">Offline Mode</span>
    <button id="syncButton" class="sync-button" onclick="syncOrders()">
        Sync (<span id="pendingOrdersCount">0</span>)
    </button>
  </div>
  
  <h1 id="mainHeader">Burnt Diner</h1>

  <div class="section">
    <label for="customerName">Customer Name</label>
    <input type="text" id="customerName" placeholder="Enter name" />
  </div>
  
  <div class="section">
    <label for="callNumber">Call Number</label>
    <select id="callNumber" style="padding: 10px; font-size: 1.1em; width: 100%; box-sizing: border-box;">
        <option value="N/A">-- Select Call Number --</option>
        </select>
  </div>

  <div class="order-interface">
    
    <div class="cart-container">
        <h2>Current Order</h2>
        <table class="cart-table">
            <thead>
                <tr>
                    <th style="width: 5%;">X</th>
                    <th style="width: 10%;">Qty</th>
                    <th style="width: 40%;">Item/Mod</th>
                    <th style="width: 15%;">Price</th>
                    <th style="width: 15%; text-align: right;">Total</th>
                </tr>
            </thead>
            <tbody id="orderCart">
                </tbody>
        </table>
        <div id="emptyCartMessage" style="text-align: center; color: #6c757d; padding: 10px;">Cart is empty.</div>
    </div>

    <div class="menu-container">
        <h2>Menu Selection</h2>
        <div id="menuButtons"></div>
    </div>
  </div>
  <div class="section">
    <label>PWD Discount Options (20% Off)</label>
    <div class="radio-group" onchange="updateSubtotal()">
      <label><input type="radio" name="pwdDiscount" value="None" checked /> **No Discount**</label>
      <label><input type="radio" name="pwdDiscount" value="HighestItem" /> Highest Priced Item Only (Shared Meal)</label>
      <label><input type="radio" name="pwdDiscount" value="WholeOrder" /> Whole Order (One Person)</label>
    </div>
    <div id="pwdWarning" class="warning" style="display:none;">⚠️ Whole Order Discount applied with multiple items. Confirm eligibility.</div>
  </div>

  <div class="total">Subtotal: ₱<span id="subtotal">0</span></div>
  <div class="discount-line">Discount Applied: ₱<span id="discountApplied">0</span></div>
  <div class="total">Total after Discount: ₱<span id="total">0</span></div>

  <div class="section">
    <label>Order Type</label>
    <div class="radio-group">
      <label><input type="radio" name="orderType" value="Dine In" checked /> Dine In</label>
      <label><input type="radio" name="orderType" value="Take Out" /> Take Out</label>
    </div>
  </div>

  <div class="section">
    <label>Payment Method</label>
    <div class="radio-group">
      <label><input type="radio" name="paymentMethod" value="Cash" checked /> Cash</label>
      <label><input type="radio" name="paymentMethod" value="GCash" /> GCash</label>
    </div>
  </div>
  
  <div class="section">
    <label for="amountPaid">Amount Paid</label>
    <input type="number" id="amountPaid" min="0" value="0" onchange="updateSubtotal()" />
    
    <div class="amount-paid-buttons">
        <button onclick="appendAmount('exact')" style="background-color: #28a745;">Exact Amount</button>
        <button onclick="appendAmount(200)">₱200</button>
        <button onclick="appendAmount(300)">₱300</button>
        <button onclick="appendAmount(400)">₱400</button>
        <button onclick="appendAmount(500)">₱500</button>
        <button onclick="appendAmount(600)">₱600</button>
        <button onclick="appendAmount(700)">₱700</button>
        <button onclick="appendAmount(1000)">₱1000</button>
        <button onclick="appendAmount('clear')">Clear</button>
    </div>
    
    <div class="total">Change: ₱<span id="change">0</span></div>
    <div id="paymentError" class="error" style="display:none;">⚠️ Amount paid is less than total.</div>
  </div>
  
  <div class="section">
    <div style="font-size: 0.8em; margin-bottom: 10px; color: #6c757d;">
      User ID: <span id="userIdDisplay">Initializing...</span>
    </div>
    <button id="printOrderButton" onclick="printReceipt()" style="background: #337ab7; margin-bottom: 10px;">🖨️ Print Receipt & Kitchen Ticket</button>
    <button id="sendOrderButton" onclick="sendOrder()">📤 Send Order & Save</button>
  </div>

  <script type="module">
    // --- Firebase SDK Imports ---
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, doc, addDoc, collection, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

    setLogLevel('Debug');

    // --- Global Variables ---
    let db, auth;
    let currentUserId = null;
    let appId = 'default-app-id';
    let isOnline = navigator.onLine; // Initial online status

    // --- IndexedDB Setup ---
    const DB_NAME = 'OfflinePOSDB';
    const DB_VERSION = 1;
    const STORE_NAME = 'pendingOrders';
    let dbInstance = null;
    
    function openDatabase() {
        return new Promise((resolve, reject) => {
            if (dbInstance) {
                return resolve(dbInstance);
            }
            const request = indexedDB.open(DB_NAME, DB_VERSION);

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME, { keyPath: 'id', autoIncrement: true });
                }
            };

            request.onsuccess = (event) => {
                dbInstance = event.target.result;
                console.log("IndexedDB opened successfully.");
                resolve(dbInstance);
                // After opening, check for pending orders
                updatePendingOrdersCount(); 
            };

            request.onerror = (event) => {
                console.error("IndexedDB error:", event.target.error);
                reject(event.target.error);
            };
        });
    }

    // Function to save an order to IndexedDB
    async function saveOrderToIndexedDB(orderData) {
        try {
            const db = await openDatabase();
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            
            // Add a unique ID for IndexedDB and a timestamp for sorting
            const indexedDBOrder = {
                ...orderData,
                offlineTimestamp: Date.now(),
                // 'id' property is added by autoIncrement
            };
            
            await new Promise((resolve, reject) => {
                const request = store.add(indexedDBOrder);
                request.onsuccess = () => resolve();
                request.onerror = (e) => reject(e);
            });
            
            updatePendingOrdersCount();
            return true;
        } catch (e) {
            console.error("Failed to save order to IndexedDB:", e);
            return false;
        }
    }
    
    // Function to get all pending orders from IndexedDB
    async function getPendingOrders() {
        try {
            const db = await openDatabase();
            const transaction = db.transaction([STORE_NAME], 'readonly');
            const store = transaction.objectStore(STORE_NAME);
            
            return await new Promise((resolve, reject) => {
                const request = store.getAll();
                request.onsuccess = () => resolve(request.result);
                request.onerror = (e) => reject(e);
            });
        } catch (e) {
            console.error("Failed to retrieve pending orders:", e);
            return [];
        }
    }

    // Function to delete a specific order from IndexedDB
    async function deleteOrderFromIndexedDB(id) {
        try {
            const db = await openDatabase();
            const transaction = db.transaction([STORE_NAME], 'readwrite');
            const store = transaction.objectStore(STORE_NAME);
            
            await new Promise((resolve, reject) => {
                const request = store.delete(id);
                request.onsuccess = () => resolve();
                request.onerror = (e) => reject(e);
            });
            updatePendingOrdersCount();
            return true;
        } catch (e) {
            console.error("Failed to delete order from IndexedDB:", e);
            return false;
        }
    }
    
    // Function to update the pending orders count in the UI
    async function updatePendingOrdersCount() {
        const orders = await getPendingOrders();
        document.getElementById("pendingOrdersCount").textContent = orders.length;
        document.getElementById("syncButton").disabled = orders.length === 0 || !isOnline;
    }

    // --- Firebase Initialization (Modified for safety) ---
    const defaultFirebaseConfig = { 
        apiKey: "AIzaSyDhofFG3SN-q3l4n4udHv7tOWT6ewb9aQ8", 
        authDomain: "burnt-pos.firebaseapp.com", 
        projectId: "burnt-pos", 
        storageBucket: "burnt-pos.firebasestorage.app", 
        messagingSenderId: "186475223375", 
        appId: "1:186475223375:web:0ecf0136f9af26985a8d3a", 
        measurementId: "G-NWTNRQ3GCM" 
    };

    let firebaseConfig;

    try {
        firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : defaultFirebaseConfig;
        appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
    } catch (e) {
        console.error("Error parsing __firebase_config, using default.", e);
        firebaseConfig = defaultFirebaseConfig;
    }

    const app = initializeApp(firebaseConfig);
    db = getFirestore(app);
    auth = getAuth(app);
    
    onAuthStateChanged(auth, async (user) => {
      if (user) {
        currentUserId = user.uid;
        document.getElementById("userIdDisplay").textContent = currentUserId;
        console.log("User signed in:", currentUserId);
        // listenToOrders(); // Disabled listening to historical orders for simplicity
      } else {
        try {
            if (typeof __initial_auth_token !== 'undefined') {
                await signInWithCustomToken(auth, __initial_auth_token);
            } else {
                await signInAnonymously(auth);
            }
        } catch (error) {
            console.error("Firebase Auth Error:", error);
            document.getElementById("userIdDisplay").textContent = "Auth Error";
        }
      }
    });
    
    // --- Network Status Handlers ---
    const statusBar = document.getElementById("statusBar");
    const statusText = document.getElementById("statusText");

    function updateNetworkStatus() {
        isOnline = navigator.onLine;
        if (isOnline) {
            statusBar.classList.remove('offline');
            statusBar.classList.add('online');
            statusText.textContent = "Online Mode (Ready to Sync)";
            // Attempt auto-sync when back online
            syncOrders(); 
        } else {
            statusBar.classList.remove('online');
            statusBar.classList.add('offline');
            statusText.textContent = "Offline Mode (Saving to Local Storage)";
        }
        updatePendingOrdersCount(); // Re-evaluate sync button state
    }

    window.addEventListener('online', updateNetworkStatus);
    window.addEventListener('offline', updateNetworkStatus);
    // Initial call is handled by initializeApp now
    // updateNetworkStatus(); 

    // --- Synchronization Function ---
    window.syncOrders = async function() {
        if (!isOnline || !currentUserId) {
            showMessage("Cannot sync: Must be online and authenticated.", true);
            return;
        }

        const syncButton = document.getElementById("syncButton");
        syncButton.disabled = true;
        syncButton.textContent = "Syncing...";
        
        const orders = await getPendingOrders();
        let successCount = 0;
        let failCount = 0;

        if (orders.length === 0) {
            showMessage("No pending orders to sync.", false);
            syncButton.textContent = `Sync (${successCount})`;
            syncButton.disabled = true;
            return;
        }
        
        const orderCollectionRef = collection(db, `artifacts/${appId}/public/data/orders`);
        
        for (const order of orders) {
            try {
                // Remove the IndexedDB ID before sending to Firestore
                const { id, ...fireStoreOrder } = order; 
                
                // Firestore automatically provides a serverTimestamp, but we use the
                // offlineTimestamp as the client-side time of creation for accuracy.
                // We must manually add the serverTimestamp property for Firestore.
                fireStoreOrder.createdAt = serverTimestamp();
                fireStoreOrder.offlineTime = order.offlineTimestamp; 
                
                await addDoc(orderCollectionRef, fireStoreOrder);
                await deleteOrderFromIndexedDB(id);
                successCount++;
            } catch (e) {
                console.error(`Failed to sync order ID ${order.id}:`, e);
                failCount++;
                // Stop syncing if the error is due to authentication or permissions
                if (e.code === 'permission-denied' || e.code === 'unauthenticated') {
                    showMessage("Sync failed: Authentication error. Try logging in again.", true);
                    break; 
                }
            }
        }
        
        syncButton.textContent = `Sync (${failCount})`;
        
        if (failCount > 0) {
            showMessage(`⚠️ Sync finished: ${successCount} orders sent, ${failCount} failed.`, true);
        } else {
            showMessage(`✅ Sync complete! ${successCount} orders sent successfully.`, false);
        }
        
        await updatePendingOrdersCount();
        syncButton.disabled = failCount > 0 || await getPendingOrders().length === 0;
    }
    
    // --- POS Application Logic ---

    const menuSections = [
      {
        icon: "🍔",
        name: "Burgers",
        items: [
          { code: "B1", name: "Single Burnt", price: 129, isBurger: true },
          { code: "B2", name: "Double Burnt", price: 179, isBurger: true },
          { code: "B3", name: "Single BLT", price: 159, isBurger: true },
          { code: "B4", name: "Double BLT", price: 209, isBurger: true },
          { code: "BU", name: "Upgrade", price: 49, isBurger: false, isUpgrade: true } 
        ]
      },
      {
        icon: "🍟",
        name: "Fries",
        items: [
          { code: "F1", name: "Chonky Fries", price: 69 }
        ]
      },
      {
        icon: "🧇",
        name: "All-Day Munchies",
        items: [
          { code: "A1", name: "Chicken & Waffles", price: 199 },
          { code: "A2", name: "Brunch Plate", price: 169 }
        ]
      },
      {
        icon: "➕",
        name: "Add-ons", 
        items: [
          { code: "AO1", name: "Waffles", price: 79 },
          { code: "AO2", name: "Cheese", price: 15 },
          { code: "AO3", name: "Bacon", price: 20 },
          { code: "AO4", name: "Pickles", price: 10 },
          { code: "AO5", name: "Onions", price: 5 },
          { code: "AO6", name: "Hashbrown", price: 30 } // NEW: Hashbrown
        ]
      },
      {
        icon: "🥤",
        name: "Milk Shakes",
        items: [
          { code: "MS1", name: "Vanilla Milk Shake", price: 119 }, 
          { code: "MS2", name: "Chocolate Milk Shake", price: 119 }, 
          { code: "MS3", name: "Strawberry Milk Shake", price: 119 }
        ]
      },
      {
        icon: "🧊",
        name: "Drinks",
        items: [
          { code: "D1", name: "House Blend Iced Tea", price: 35, isDrink: true },
          { code: "D2", name: "Sodas", price: 25, isDrink: true }
        ]
      }
    ];
    
    // Burger modification options for the modal
    const burgerModificationOptions = {
        'Pickles': ['Default', 'On the side', 'Remove'],
        'Onions': ['Default', 'On the side', 'Remove'],
        'Tomato': ['Default', 'On the side', 'Remove'],
        'Lettuce': ['Default', 'On the side', 'Remove'],
        'Bacon': ['Default', 'On the side', 'Remove'],
        'Cheese': ['Default', 'On the side', 'Remove'],
        'Sauce': ['Default', 'On the side', 'Remove'],
        'Buns': ['Default', 'On the side', 'Remove']
    };
    
    // Drink modification options for the modal
    const drinkModificationOptions = ['Iced Tea', 'Coke', 'Sprite', 'Royal'];

    // Combine all items into a map for quick lookup
    const menuItemsMap = new Map(menuSections.flatMap(section => section.items).map(item => [item.code, item]));
    
    // Global variable to track the unique ID for each cart item (for easy removal/update)
    let cartItemCounter = 0;
    
    // Global object to hold item modification data
    const cartModifications = {};


    const subtotalDisplay = document.getElementById("subtotal");
    const discountAppliedDisplay = document.getElementById("discountApplied"); 
    const totalDisplay = document.getElementById("total");
    const changeDisplay = document.getElementById("change");
    const pwdWarning = document.getElementById("pwdWarning");
    const paymentError = document.getElementById("paymentError");
    const messageBox = document.getElementById("messageBox");
    const amountPaidInput = document.getElementById("amountPaid");
    const orderCartBody = document.getElementById("orderCart");
    const emptyCartMessage = document.getElementById("emptyCartMessage");
    // Modal elements
    const modificationModal = document.getElementById("modificationModal");
    const modalContent = document.getElementById("modalContent");
    const modalHeader = document.getElementById("modalItemHeader");
    const modalModificationsDiv = document.getElementById("modalModifications");
    const modalFreeTextarea = document.getElementById("modalFreeText");
    const callNumberSelect = document.getElementById("callNumber");

    // Helper function to show a temporary message
    function showMessage(msg, isError = false) {
      messageBox.textContent = msg;
      messageBox.style.backgroundColor = isError ? '#dc3545' : '#28a745';
      messageBox.style.opacity = 1;
      messageBox.style.transform = 'translateX(-50%) translateY(0)';
      
      setTimeout(() => {
        messageBox.style.opacity = 0;
        messageBox.style.transform = 'translateX(-50%) translateY(-20px)';
      }, 3000);
    }
    
    // Function to quickly set Amount Paid (MODIFIED for 'exact')
    window.appendAmount = function(amount) {
        if (amount === 'clear') {
            amountPaidInput.value = 0;
        } else if (amount === 'exact') {
            // Use the Total after Discount amount for 'exact'
            const total = parseFloat(document.getElementById("total").textContent);
            amountPaidInput.value = total > 0 ? total : 0;
        } else {
            amountPaidInput.value = amount;
        }
        updateSubtotal();
    }

    // Function to trigger browser print
    window.printReceipt = function() {
        const total = parseFloat(document.getElementById("total").textContent);
        
        if (total === 0) {
            showMessage("Cart is empty. Cannot print receipt.", true);
            return;
        }
        
        // 1. Prepare item data for print (set attributes and notes for the print script)
        const cartRows = document.querySelectorAll(".cart-item-row");
        cartRows.forEach(row => {
            const uniqueId = row.getAttribute("data-item-id");
            // Get current quantity and set it as an attribute for the script to use
            const qty = document.querySelector(`[data-input-id="qty-${uniqueId}"]`).value;
            row.children[1].setAttribute('data-qty-value', qty); 
            
            // Ensure the hidden input has the correct note content for the print script to pick up
            const noteContent = document.querySelector(`[data-display-id="note-${uniqueId}"]`).textContent;
            document.querySelector(`[data-print-note-id="note-${uniqueId}"]`).value = noteContent;
        });
        
        // 2. Trigger the original buildReceipt function in the global script block
        if (window._origPrintReceipt) {
            window._origPrintReceipt();
        } else {
            // Fallback for direct module access
            console.warn("Using default print for unified ticket.");
            window.print();
        }
    }
    
    // NEW: Function to display the modification modal
    window.showModificationModal = function(uniqueId, itemCode) {
        const item = menuItemsMap.get(itemCode);
        if (!item) return;

        // Store the unique ID being modified
        modificationModal.setAttribute('data-modifying-id', uniqueId);
        
        // Load current modifications or initialize to default
        const currentMods = cartModifications[uniqueId] || { options: {}, freeText: '' };
        
        modalHeader.textContent = `Modify: ${item.name} (${item.code})`;
        modalModificationsDiv.innerHTML = '';
        modalFreeTextarea.value = currentMods.freeText;
        
        // Check if the item is a Burger OR is the Upgrade item
        const isBurgerOrUpgrade = item.isBurger || item.code === 'BU'; // Only BU gets burger mods for now
        // Check if the item is a Drink OR is the Upgrade item
        const isDrinkOrUpgrade = item.isDrink || item.isUpgrade;

        if (isBurgerOrUpgrade) {
            // Build Burger Modification UI
            for (const key in burgerModificationOptions) {
                const groupDiv = document.createElement('div');
                groupDiv.classList.add('modification-group');
                let html = `<label>${key}</label>`;
                
                burgerModificationOptions[key].forEach(option => {
                    const optionKey = key.replace(/\s/g, ''); // e.g., 'Pickles'
                    const isChecked = (currentMods.options[optionKey] || 'Default') === option;
                    
                    html += `
                        <label>
                            <input type="radio" 
                                name="mod-${uniqueId}-${optionKey}" 
                                value="${option}"
                                ${isChecked ? 'checked' : ''}
                            /> ${option}
                        </label>
                    `;
                });
                groupDiv.innerHTML = html;
                modalModificationsDiv.appendChild(groupDiv);
            }
        }
        
        if (isDrinkOrUpgrade) {
            // Build Drink Modification UI (Dropdown)
            const groupDiv = document.createElement('div');
            groupDiv.classList.add('modification-group');
            let html = `<label>Drink Choice</label>`;
            const currentChoice = currentMods.options['DrinkChoice'] || drinkModificationOptions[0]; // Default to first drink

            html += `<select name="mod-${uniqueId}-DrinkChoice">`;
            drinkModificationOptions.forEach(option => {
                const isSelected = currentChoice === option;
                html += `<option value="${option}" ${isSelected ? 'selected' : ''}>${option}</option>`;
            });
            html += `</select>`;
            
            groupDiv.innerHTML = html;
            modalModificationsDiv.appendChild(groupDiv);
        }

        // Show/Hide structured mods based on whether any were generated
        modalModificationsDiv.style.display = (isBurgerOrUpgrade || isDrinkOrUpgrade) ? 'block' : 'none';
        
        // Show the free text section always
        document.getElementById('freeTextGroup').style.display = 'block';

        modificationModal.style.display = 'flex';
    }
    
    // NEW: Function to save the modifications from the modal
    window.saveModifications = function() {
        const uniqueId = modificationModal.getAttribute('data-modifying-id');
        const itemRow = document.querySelector(`[data-item-id="${uniqueId}"]`);
        if (!itemRow) return;
        
        const itemCode = itemRow.getAttribute('data-item-code');
        const item = menuItemsMap.get(itemCode);
        
        const newMods = {
            options: {},
            freeText: modalFreeTextarea.value.trim()
        };
        
        const isBurgerOrUpgrade = item.isBurger || item.code === 'BU'; // Only BU gets burger mods for now
        const isDrinkOrUpgrade = item.isDrink || item.isUpgrade;

        if (isBurgerOrUpgrade) {
            // Collect radio button values
            for (const key in burgerModificationOptions) {
                const optionKey = key.replace(/\s/g, '');
                const selectedEl = document.querySelector(`input[name="mod-${uniqueId}-${optionKey}"]:checked`);
                newMods.options[optionKey] = selectedEl ? selectedEl.value : 'Default';
            }
        }
        
        if (isDrinkOrUpgrade) {
             // Collect dropdown value
            const selectEl = document.querySelector(`select[name="mod-${uniqueId}-DrinkChoice"]`);
            if(selectEl) {
                newMods.options['DrinkChoice'] = selectEl.value;
            } else {
                 // For BU/Drink items, if the dropdown wasn't displayed but should have been,
                 // we must check if we need to initialize the DrinkChoice
                 if ((item.isUpgrade || item.isDrink) && !newMods.options['DrinkChoice']) {
                    newMods.options['DrinkChoice'] = drinkModificationOptions[0];
                 }
            }
        }

        // Save to global modifications object
        cartModifications[uniqueId] = newMods;
        
        // Update the visible note on the cart row
        updateCartNoteDisplay(uniqueId);
        
        modificationModal.style.display = 'none';
    }
    
    // NEW: Function to update the note text on the cart row
    function updateCartNoteDisplay(uniqueId) {
        const mods = cartModifications[uniqueId];
        const itemCode = document.querySelector(`[data-item-id="${uniqueId}"]`).getAttribute('data-item-code');
        const item = menuItemsMap.get(itemCode);
        const noteDisplayEl = document.querySelector(`[data-display-id="note-${uniqueId}"]`);
        
        if (!mods || !noteDisplayEl) return;
        
        let modNotes = [];
        
        const isBurgerOrUpgrade = item.isBurger || item.code === 'BU'; // Only BU gets burger mods for now
        const isDrinkOrUpgrade = item.isDrink || item.isUpgrade;

        if (isBurgerOrUpgrade) {
            for (const key in mods.options) {
                if (mods.options[key] !== 'Default') {
                    modNotes.push(`${key}: ${mods.options[key]}`);
                }
            }
        }
        
        if (isDrinkOrUpgrade && mods.options['DrinkChoice']) {
             modNotes.push(`Drink Choice: ${mods.options['DrinkChoice']}`);
        }

        if (mods.freeText) {
            modNotes.push(`Note: ${mods.freeText}`);
        }
        
        const combinedNote = modNotes.join(' | ');
        noteDisplayEl.textContent = combinedNote;
        
        // For print, we use a hidden element to store the modification string
        const printNoteEl = document.querySelector(`[data-print-note-id="note-${uniqueId}"]`);
        if (printNoteEl) {
            printNoteEl.value = combinedNote;
        }
        
        // Change button color if modifications exist
        const modifyBtn = document.querySelector(`[onclick="showModificationModal('${uniqueId}', '${itemCode}')"]`);
        if (modifyBtn) {
            modifyBtn.style.backgroundColor = combinedNote ? '#28a745' : '#007bff'; // Green if modifed, Blue otherwise
        }
    }
    
    // Function to add an item to the cart (UPDATED: Handle BU/Upgrade default drink choice)
    window.addItemToCart = function(itemCode) {
        const item = menuItemsMap.get(itemCode);
        if (!item) return;

        cartItemCounter++;
        const uniqueId = `cart-${cartItemCounter}`;
        
        // Initialize modifications for this new item
        cartModifications[uniqueId] = { options: {}, freeText: '' };
        
        // Set default drink choice if it's a drink or upgrade item
        if (item.isDrink || item.isUpgrade) {
            cartModifications[uniqueId].options['DrinkChoice'] = drinkModificationOptions[0]; // Default to Iced Tea
        }


        const itemRow = document.createElement("tr");
        itemRow.classList.add("cart-item-row");
        itemRow.setAttribute("data-item-id", uniqueId);
        itemRow.setAttribute("data-item-code", item.code); 
        itemRow.setAttribute("data-price", item.price);

        itemRow.innerHTML = `
            <td><button class="cart-remove-button" onclick="removeItemFromCart('${uniqueId}')">X</button></td>
            <td>
                <input type="number" min="1" value="1" onchange="updateSubtotal()" data-input-id="qty-${uniqueId}" />
            </td>
            <td>
                <strong>${item.name} (${item.code})</strong>
                <button class="cart-modify-button" onclick="showModificationModal('${uniqueId}', '${item.code}')">Modify</button>
                <div data-display-id="note-${uniqueId}" style="font-size: 0.8em; color: #6c757d; margin-top: 5px;"></div>
                <input type="hidden" data-print-note-id="note-${uniqueId}" value="" /> 
            </td>
            <td>₱${item.price}</td>
            <td style="text-align: right;">₱<span data-display-id="total-${uniqueId}">${item.price}</span></td>
        `;

        orderCartBody.appendChild(itemRow);
        // Initial setup of display notes and button color (This will display the default Drink Choice for BU/D items)
        updateCartNoteDisplay(uniqueId);
        updateCartDisplay(); 
        updateSubtotal();
    }
    
    // Function to remove an item from the cart (UPDATED: Remove from cartModifications)
    window.removeItemFromCart = function(uniqueId) {
        const itemRow = document.querySelector(`[data-item-id="${uniqueId}"]`);
        if (itemRow) {
            itemRow.remove();
            // Remove the modification data as well
            delete cartModifications[uniqueId]; 
            updateCartDisplay();
            updateSubtotal();
        }
    }

    // Function to update the visibility of the "Cart is empty" message
    function updateCartDisplay() {
        if (orderCartBody.children.length === 0) {
            emptyCartMessage.style.display = 'block';
        } else {
            emptyCartMessage.style.display = 'none';
        }
    }


    // Function to calculate and update totals (FIXED LOGIC)
    window.updateSubtotal = function() {
      let rawSubtotal = 0; // Total before discount
      let totalQty = 0;
      let discountAmount = 0;
      let highestItemTotal = 0;
      
      const cartRows = document.querySelectorAll(".cart-item-row");
      const discountMethod = document.querySelector('input[name="pwdDiscount"]:checked').value;
      
      // Early exit if no items are in the cart
      if (cartRows.length === 0) {
          subtotalDisplay.textContent = '0';
          discountAppliedDisplay.textContent = '0';
          totalDisplay.textContent = '0';
          changeDisplay.textContent = '0';
          pwdWarning.style.display = "none";
          document.getElementById("sendOrderButton").disabled = true;
          return; 
      }

      // 1. Calculate Raw Subtotal, Total Quantity, and find Highest Priced Item Total
      cartRows.forEach(row => {
        const uniqueId = row.getAttribute("data-item-id");
        const price = parseFloat(row.getAttribute("data-price"));
        // Get quantity from the dynamically created input
        const qty = parseInt(document.querySelector(`[data-input-id="qty-${uniqueId}"]`).value) || 0;
        
        const lineTotal = price * qty;
        rawSubtotal += lineTotal;
        totalQty += qty;
        
        if (lineTotal > highestItemTotal) {
            highestItemTotal = lineTotal;
        }
        
        // Update the line total display
        document.querySelector(`[data-display-id="total-${uniqueId}"]`).textContent = lineTotal.toFixed(0);
      });

      // 2. Apply Discount Logic
      if (discountMethod === "WholeOrder") {
        discountAmount = rawSubtotal * 0.20;
        // Show warning if Whole Order Discount is applied with multiple items
        pwdWarning.style.display = totalQty > 1 ? "block" : "none";
      } else if (discountMethod === "HighestItem") {
        discountAmount = highestItemTotal * 0.20;
        pwdWarning.style.display = "none"; 
      } else { // "None"
        discountAmount = 0;
        pwdWarning.style.display = "none";
      }
      
      // Round discount and calculate final total
      discountAmount = Math.round(discountAmount); 
      let finalTotal = rawSubtotal - discountAmount;
      
      // 3. Update Displays
      // FIX: Set subtotalDisplay to the RAW Subtotal before discount
      subtotalDisplay.textContent = rawSubtotal.toFixed(0);
      discountAppliedDisplay.textContent = discountAmount.toFixed(0);
      // Set totalDisplay to the FINAL Total after discount
      totalDisplay.textContent = finalTotal.toFixed(0);

      const amountPaid = parseFloat(document.getElementById("amountPaid").value) || 0;
      const change = amountPaid - finalTotal;
      changeDisplay.textContent = change >= 0 ? change.toFixed(0) : 0;
      paymentError.style.display = change < 0 ? "block" : "none";
      
      // Prevent order if payment is insufficient or total is zero (empty cart)
      document.getElementById("sendOrderButton").disabled = change < 0 || finalTotal === 0;
    }

    // Function to send the order (UPDATED: Pulls Call Number)
    window.sendOrder = async function() {
      if (!currentUserId) {
        showMessage("System initializing. Please wait for authentication.", true);
        return;
      }
      
      const cartRows = document.querySelectorAll(".cart-item-row");
      if (cartRows.length === 0) {
        showMessage("Please add items to the order.", true);
        return;
      }

      const customerName = document.getElementById("customerName").value.trim() || "N/A";
      const callNumber = document.getElementById("callNumber").value; // Capture Call Number
      const orderType = document.querySelector('input[name="orderType"]:checked').value;
      const paymentMethod = document.querySelector('input[name="paymentMethod"]:checked').value;
      const amountPaid = parseFloat(document.getElementById("amountPaid").value) || 0;
      const total = parseInt(document.getElementById("total").textContent);
      const change = parseInt(document.getElementById("change").textContent);
      
      const discountMethod = document.querySelector('input[name="pwdDiscount"]:checked').value;
      const discountAmount = parseInt(document.getElementById("discountApplied").textContent);

      // Collect items, quantities, and line item notes from the cart
      const items = [];
      cartRows.forEach(row => {
        const uniqueId = row.getAttribute("data-item-id");
        const itemCode = row.getAttribute("data-item-code");
        const itemPrice = parseFloat(row.getAttribute("data-price"));
        
        const qtyInput = document.querySelector(`[data-input-id="qty-${uniqueId}"]`);
        const qty = parseInt(qtyInput.value) || 0;
        const itemName = menuItemsMap.get(itemCode).name;
        
        // Get modifications from the global object
        const itemModifications = cartModifications[uniqueId] || { options: {}, freeText: '' };
        
        if (qty > 0) {
            items.push({ 
                code: itemCode, 
                name: itemName, 
                qty, 
                price: itemPrice,
                modifications: itemModifications // Save the structured mods
            });
        }
      });
      
      if (items.length === 0) {
          showMessage("Please add items to the order.", true);
          return;
      }

      if (total > amountPaid) {
          showMessage("Payment amount is insufficient.", true);
          return;
      }

      const orderData = {
        customerName,
        callNumber, // ADDED Call Number
        orderType,
        paymentMethod,
        amountPaid: amountPaid, 
        total: total,
        change: change,
        discountType: discountMethod,
        discountAmount: discountAmount,
        items, 
        status: isOnline ? 'saved' : 'pending_offline', // Track status
        createdBy: currentUserId
      };

      let saveSuccess = false;
      
      if (isOnline) {
        // ONLINE: Send directly to Firestore
        try {
            const orderCollectionRef = collection(db, `artifacts/${appId}/public/data/orders`);
            // Add serverTimestamp for creation time
            orderData.createdAt = serverTimestamp(); 
            await addDoc(orderCollectionRef, orderData);
            
            showMessage(`✅ Order for ${customerName} (Call #${callNumber}) saved successfully to Firestore!`, false);
            saveSuccess = true;
        } catch (e) {
            console.error("Error adding document to Firestore. Falling back to offline save:", e);
            showMessage("❌ Failed to save online. Saving to local storage instead.", true);
            // Fallback to offline if online save fails
            saveSuccess = await saveOrderToIndexedDB(orderData);
        }
      } else {
        // OFFLINE: Save to IndexedDB
        saveSuccess = await saveOrderToIndexedDB(orderData);
        if (saveSuccess) {
            showMessage(`✅ Order for ${customerName} (Call #${callNumber}) saved locally. Sync when online!`, false);
        } else {
            showMessage("❌ Failed to save order locally. Service unavailable.", true);
        }
      }

      if (saveSuccess) {
          // Reset form on successful save (online or offline)
          document.getElementById("customerName").value = "";
          document.getElementById("amountPaid").value = "0";
          document.getElementById("callNumber").value = "N/A"; // Reset Call Number
          document.querySelector('input[name="pwdDiscount"][value="None"]').checked = true; 
          document.querySelector('input[name="orderType"][value="Dine In"]').checked = true;
          document.querySelector('input[name="paymentMethod"][value="Cash"]').checked = true;
          
          // Clear the cart and modifications
          orderCartBody.innerHTML = "";
          for (const key in cartModifications) {
              delete cartModifications[key];
          }
          updateCartDisplay();
          updateSubtotal(); 
      }
    }
    
    // Original listener function (kept but unused for the scope of offline sync)
    function listenToOrders() {
        /*
        const orderCollectionRef = collection(db, `artifacts/${appId}/public/data/orders`);
        const q = query(orderCollectionRef, limit(5));

        const unsubscribe = onSnapshot(q, (snapshot) => {
            snapshot.docChanges().forEach((change) => {
                const order = change.doc.data();
                if (change.type === "added") {
                    console.log("New Order Added:", order.customerName, order.total);
                }
            });
        }, (error) => {
            console.error("Error listening to orders:", error);
        });
        */
    }

    // Initialize Menu Buttons
    function initializeMenuButtons() {
        console.log("Initializing Menu Buttons..."); 
        const menuButtonsDiv = document.getElementById("menuButtons");
        if (!menuButtonsDiv) {
            console.error("DOM element #menuButtons not found. Cannot initialize menu.");
            return;
        }

        menuButtonsDiv.innerHTML = ""; 

        menuSections.forEach(section => {
            // Create a heading for each section
            const sectionHeader = document.createElement("h3");
            sectionHeader.textContent = `${section.icon} ${section.name}`;
            sectionHeader.style.cssText = "margin-top: 15px; margin-bottom: 5px; color: #d9534f; border-bottom: 1px solid #eee;";
            menuButtonsDiv.appendChild(sectionHeader);

            // Create a grid container for the items in the section
            const grid = document.createElement("div");
            grid.classList.add("menu-grid");

            section.items.forEach(item => {
                const button = document.createElement("button");
                button.classList.add("menu-button");
                button.textContent = `${item.code} - ${item.name} (₱${item.price})`;
                button.onclick = () => addItemToCart(item.code); 
                grid.appendChild(button);
            });
            menuButtonsDiv.appendChild(grid);
        });
        console.log("Menu Buttons initialized successfully.");
    }

    // NEW: Function to populate Call Number Dropdown
    function initializeCallNumberDropdown() {
        const select = document.getElementById('callNumber');
        if (!select) return;

        for (let i = 1; i <= 30; i++) {
            const option = document.createElement('option');
            option.value = i;
            option.textContent = i;
            select.appendChild(option);
        }
    }

    // Core app setup logic (excluding menu buttons)
    function initializeAppCore() {
        console.log("Starting POS App Core initialization.");
        initializeCallNumberDropdown(); // Initialize new element
        updateCartDisplay();
        updateSubtotal();
        updateNetworkStatus(); 
        openDatabase(); 
    }
    
    // --- FINAL Initialization: Prioritize Menu and then run Core App Logic ---
    window.addEventListener('DOMContentLoaded', () => {
        initializeMenuButtons(); 
        initializeAppCore();
        // Hide modal when clicking overlay
        modificationModal.addEventListener('click', (e) => {
            if (e.target === modificationModal) {
                modificationModal.style.display = 'none';
            }
        });
    });
    
    // Expose closeModal for the close button
    window.closeModal = function() {
        modificationModal.style.display = 'none';
    }
  </script>
  </div>
  
<div id="modificationModal" class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <h3 id="modalItemHeader">Modify Item</h3>
            <button class="modal-close" onclick="closeModal()">&times;</button>
        </div>
        <div id="modalModifications">
            </div>
        <div id="freeTextGroup" class="modification-group">
            <label for="modalFreeText">Additional/Unlisted Customization</label>
            <textarea id="modalFreeText" rows="3" placeholder="e.g., Well-done patty, Extra crispy fries..."></textarea>
        </div>
        <div class="modal-actions">
            <button style="background: #28a745;" onclick="saveModifications()">Save Modifications</button>
            <button style="background: #aaa;" onclick="closeModal()">Cancel</button>
        </div>
    </div>
</div>

  <div id="printArea" style="display:none">
    <div class="receipt" id="receipt"></div>
  </div>

<script>
// This block handles the print receipt generation logic (Kitchen Ticket)
(function(){
  function peso(n){ return `₱${Number(n).toFixed(0)}`; }
  function esc(s){ return String(s||'').replace(/[&<>\"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m])); }

  function buildReceipt(){
    const receipt = document.getElementById('receipt');
    if(!receipt) return;

    // Get inputs
    const rawName = (document.getElementById('customerName')?.value || 'Walk-in').trim();
    const name = rawName || 'Walk-in';
    const callNumber = (document.getElementById('callNumber')?.value || 'N/A').toUpperCase(); 
    const orderType = ((document.querySelector('input[name="orderType"]:checked')||{}).value || 'Dine In').toUpperCase();
    
    // New required details
    const restaurantName = document.getElementById('mainHeader').textContent.trim().toUpperCase();
    const dateTime = new Date().toLocaleString();
    const subtotal = document.getElementById('subtotal').textContent; // Raw Subtotal (Pre-Discount)
    const discount = document.getElementById('discountApplied').textContent;
    const total = document.getElementById('total').textContent; // Final Total (Post-Discount)

    
    // Collect items
    const rows = Array.from(document.querySelectorAll('.cart-item-row')).map(row => {
      const id = row.getAttribute('data-item-id') || '';
      // Get the final note string from the hidden input (populated just before print)
      const noteEl = document.querySelector(`[data-print-note-id="note-${id}"]`); 
      
      const qtyEl = document.querySelector(`[data-input-id="qty-${id}"]`);
      const qty = parseInt(qtyEl?.value || '0', 10);
      
      // Extract name from <strong> but strip trailing " (CODE)"
      let nm = row.querySelector('td:nth-child(3) strong')?.textContent?.trim() || 'Item';
      nm = nm.replace(/\s*\([A-Za-z0-9]+\)\s*$/, ''); 
      
      const note = (noteEl?.value || '').trim();
      return { qty, name:nm, note };
    }).filter(x => x.qty > 0);

    // Compose final text output (Kitchen Ticket style with summary data)
    let lines = [];
    
    // --- Restaurant Header and Date/Time ---
    lines.push(`\n${restaurantName}`);
    lines.push(dateTime);
    lines.push(`--------------------------------`);
    
    // --- Order Details ---
    lines.push(`CALL NUMBER: ${callNumber}`); 
    lines.push(`CUSTOMER: ${name}`);
    lines.push(`ORDER TYPE: ${orderType}`);
    lines.push(`--------------------------------`);
    
    // --- Item List ---
    rows.forEach(r => {
      const notePart = r.note ? ` | ${r.note}` : ''; 
      lines.push(`${r.qty} x ${r.name}${notePart}`);
    });
    
    lines.push(`--------------------------------`);
    
    // --- Financial Summary (using the now-correct values) ---
    lines.push(`SUBTOTAL: ₱${subtotal}`);
    if (parseFloat(discount) > 0) {
        lines.push(`DISCOUNT: -₱${discount}`);
    }
    lines.push(`TOTAL: ₱${total}`);
    lines.push(`--------------------------------`);
    
    receipt.textContent = lines.join('\n');
    
    // Ensure the receipt div is visible when printing
    receipt.style.display = 'block';

  }

  // Safely override after page scripts have defined the original function
  const onReady = () => {
    // Store the original function body
    const orig = window.printReceipt;
    window._origPrintReceipt = orig;
    
    window.printReceipt = function(){
      try { 
          // 1. Prepare item data attributes (for the old logic)
          const cartRows = document.querySelectorAll(".cart-item-row");
          cartRows.forEach(row => {
              const uniqueId = row.getAttribute("data-item-id");
              const qty = document.querySelector(`[data-input-id="qty-${uniqueId}"]`).value;
              row.children[1].setAttribute('data-qty-value', qty); 
              
              // Ensure the hidden input has the correct note content for buildReceipt()
              const noteContent = document.querySelector(`[data-display-id="note-${uniqueId}"]`).textContent;
              document.querySelector(`[data-print-note-id="note-${uniqueId}"]`).value = noteContent;
          });
          
          // 2. Build and set the content of the hidden print receipt div
          buildReceipt(); 
          
      } catch(e){ 
          console.error('Print setup failed', e); 
      }
      // 3. Trigger print (which will only show the styled #printArea)
      window.print();
    };
  };
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', onReady);
  } else {
    onReady();
  }
})();
</script>

</body>
</html>